Thoughts here are that this gitlab repo "dora_containernet" will contain the submodules for both containernet and dora. The "pre_build" stage of this gitlab-ci.yml should only run if either the "dora" or "containernet" repos get a push, the pipeline will be triggered. We run a git submodule update --init to get the latest updates on both repos. Now we pass the Dockerfile for dora from "dora_containernet" into the "dora" repo submodule (since dora does not currently have a Dockerfile), and initiate a docker build proccess for both containernet and dora images. Once these builds are complete, we build a final image using COPY --from commands pulling from both the dora and containernet images. This image will be called "test_image" which will run through the tests specified in the pipelines and if the pipeline passes, it pushes "test_image" to the container registery tagging it "dora_containernet:latest" and gives some sort of success message. 

However if no changes have been made to either submodule "dora" or "containernet" but the pipeline is triggered, 
it should skip the pre_build step, and just build the image that is already labled as "dora_containernet" in the 
projects container registry, then run the tests, if all passes give some sort of success message.

############################################################################################################################################################
Here are my thoughts on this gitlab project "dora_containernet", the repository itself will have two git submodules "dora" and "containernet". If any changes are made to either of these repositories the expected result is to trigger the pipeline in the "dora_containerent" project. The gitlab-ci.yml file should have 4 stages "pre_build", "build", "test", "deploy" (we can add more or take away if we feel its the best option). If the pipeline is triggered due to a change made in either of these repositories, I want only the pre_build, test, and deploy stages to run. 

The pre build should run a git submodule update --init to get the latest updates on both repos. Then pass the Dockerfile.dora from the "dora_containernet" project into the "dora" git submodule (since dora does not currently have a Dockerfile). Next it should initiate a "docker build" in both of the submodules containernet and dora. The build proccess should include tagging the images as dora:latest and containernet:latest repectivley. Once these builds are complete, we build a final image that contains . This image will be called "test_image" which will run through the tests specified in the pipelines and if the pipeline passes, it pushes "test_image" to the container registery tagging it "dora_containernet:latest" and gives some sort of success message. 

The pipeline can be triggered in three different ways. The first of which will be if any changes are made to either the "dora" or "containernet" repositories. 

The other one of the pipelines will be my development teams pipeline. If they 





Here's an outline of how the pipeline might be structured:

image: docker:20.10.16
services:
  - docker:20.10.16-dind

stages:
  - pre_build
  - build
  - test
  - deploy

variables:
  # Use TLS https://docs.gitlab.com/ee/ci/docker/using_docker_build.html#tls-enabled
  DOCKER_HOST: tcp://docker:2376
  DOCKER_TLS_CERTDIR: "/certs"
  CONTAINER_TEST_IMAGE: $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_SLUG
  CONTAINER_RELEASE_IMAGE: $CI_REGISTRY_IMAGE:latest

before_script:
  - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY

pre_build:
  stage: pre_build
  only:
    changes:
      - dora_containernet/*
  script:
    - git submodule update --init
    - cp ./dora_containernet/Dockerfile.dora ./dora/Dockerfile
    - docker build -t containernet ./containernet/
    - docker build -t dora ./dora/
  
build:
  stage: build
  except:
    changes:
      - dora_containernet/*
  script:
    - docker pull <your-registry>/<your-namespace>/dora_containernet:latest || true
    - docker build -t containernet ./containernet/
    - docker build -t dora ./dora/
    - docker build --cache-from <your-registry>/<your-namespace>/dora_containernet:latest -t <your-registry>/<your-namespace>/dora_containernet:test -f ./dora_containernet/Dockerfile .

test:
  stage: test
  script:
    - docker run <your-registry>/<your-namespace>/dora_containernet:test <your-test-command>

deploy:
  stage: deploy
  script:
    - docker push <your-registry>/<your-namespace>/dora_containernet:test

In this pipeline, there are four stages: pre_build, build, test, and deploy.

The pre_build stage runs only if changes have been made to the dora_containernet directory. It initializes and 
updates the submodules, copies the Dockerfile from dora_containernet to dora, and builds the containernet and 
dora images.

The build stage runs if changes have not been made to the dora_containernet directory. It pulls the latest 
dora_containernet image from the registry (if it exists), builds the containernet and dora images, and then 
builds the dora_containernet image using the Dockerfile in dora_containernet, pulling the cache from the latest 
image in the registry.

The test stage runs the tests on the dora_containernet image.

The deploy stage pushes the dora_containernet image to the registry.

This pipeline should accomplish the workflow you described. Note that you will need to replace <your-registry> and 
<your-namespace> with the appropriate values for your registry.

Maybe look into how docker outputs the "hello world" message to user console. We will either want to start outputting messages about dora logs/fails/succeeds/whatever to user console or even packaging up all test result into a file, then sending back to dev team fo review


docker run --name containernet -it --rm --privileged --pid='host' \
-v /var/run/docker.sock:/var/run/docker.sock \
-v /lib/modules:/lib/modules \
containernet/containernet /bin/bash